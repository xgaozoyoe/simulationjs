<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"></script>
</head>
	
<script>

var rand_integer = function(ceil) {
	return Math.floor(ceil * Math.random ());
}

/* x must in width range and y must in height range */

var box_boundary_out = function(top, right, bottom, left, loc) {
    return (loc.x < left || loc.x >= right || loc.y < top || loc.y >= bottom);
}

function map_boundary(map) {
	var fn = function(loc) {
		return box_boundary_out(0,map.width,map.height,0,loc);
	}
	return fn;
}

function coordinate(x, y, map) {
	this.map = map;
	this.x = x;
	this.y = y;
}

function tile(loc, res) {
	this.loc = loc;
	this.res = res;
	this.reg = 0;
	this.regen_rate = 10;
	this.slice = 0;
	this.regenerate = function(){
		if (this.slice == this.reg_rate){
			this.slice = 0;
			this.res += this.reg;
		}else{
			this.slice += 1;
		}
	}
}

function map(width, height) {
	this.width = width;
	this.height = height;
	this.boundary = [map_boundary(this)];
	this.offset = function(loc, x, y) {
		var new_loc = new coordinate(loc.x + x, loc.y + y, this);
		for(var i = 0; i < this.boundary.length; i++) {
			var out = this.boundary[i](new_loc);
			if (out) {
				return null;
			}
		}
		return new_loc;
	}
	this.tiles = new Array();
	for (var i=0; i<width; i++) {
		for (var j=0; j<height; j++) {
			this.tiles[j * width + i] = new tile({x:i, y:j}, 0);
			this.tiles[j * width + i].reg = rand_integer(5);
			this.tiles[j * width + i].reg_rate = rand_integer(10)+30;
		}
	}
	this.set_tile_resource = function(x, y, v){
		this.tiles[y * width + x ].res = v;
	}
	this.get_tile_resource = function(x,y) {
		return this.tiles[y * width + x].res;
	}

	this.regenerate = function(){
		for (var i=0; i<width; i++) {
			for (var j=0; j<height; j++) {
					this.tiles[j * width + i].regenerate();
			}
		}
	}
	this.get_tile = function(x,y){
		return this.tiles[y*width + x];
	}
}

var t = new map(1,1);

var Action = function(name, category, act, attempt){
    this.name = name;
	this.category = category;
    this.do = act;
    this.attempt = attempt;
}

var ActionCategory = {
	ACTION_MOVE:1,
	ACTION_AFFEND:2,
	ACTION_DEFEND:3,
	ACTION_COLLECT:4
}
/* Standard movement action functor */
var move = function(direction) {
    var fn = function (loc) {
		var attempt_loc = direction(loc);
		if (loc.map.offset(attempt_loc, 0, 0) != null) {
			return attempt_loc;
		} else {
			return loc;
		}
	}
	return fn;
}

var try_move = function(direction) {
    var fn = function (loc) {
		var attempt_loc = direction(loc);
		if (loc.map.offset(attempt_loc, 0, 0) != null) {
			return attempt_loc;
		} else {
			null;
		}
	}
	return fn;
}

var stay = function(loc){
	return loc;
}

function _left(loc) {return new coordinate(loc.x-1, loc.y, loc.map);} 
function _right(loc) {return new coordinate(loc.x+1, loc.y, loc.map);} 
function _top(loc) {return new coordinate(loc.x, loc.y-1, loc.map);} 
function _bottom(loc) {return new coordinate(loc.x, loc.y+1, loc.map);} 

/* For general actions an agent can take */
var move_left =  new Action("MLeft", ActionCategory.ACTION_MOVE, move(_left), try_move(_left));
var move_right = new Action("MRight", ActionCategory.ACTION_MOVE, move(_right), try_move(_right));
var move_top = new Action("MTop", ActionCategory.ACTION_MOVE, move(_top), try_move(_top));
var move_bottom = new Action("MBottom", ActionCategory.ACTION_MOVE, move(_bottom), try_move(_bottom));
var stay = new Action("MStay", ActionCategory.ACTION_COLLECT, stay, stay);

var actions = [stay, move_left, move_right, move_top, move_bottom];

/* Provided an agent, create an array of actions */
function generate_actions(agent) {
	return actions;
}

var map_gain = function (map, loc, action) {
	if (loc != null) {
		if (action.category == ActionCategory.ACTION_MOVE) {
			return 0;
		}
		if (action.category == ActionCategory.ACTION_COLLECT) {
			return map.get_tile_resource(loc.x, loc.y);
		}
		console.error("unsupported action!");
	} else {
		return -1;
	}
}

var Matrix2D = function(width, height){
	/* An Array of Array */
	/* (0,0) (1,0) 
	   (0,1) (1,1)
	 */
	this.data = new Array();
	this.width = width;
	this.height = height;
	for (var j=0; j<this.height; j++) {
		this.data[j] = new Array();
		for (var i=0; i<this.width; i++) {
			this.data[j][i] = 0;
		}
	}
	
	this.coordinate = function(x, y){
		if (x>=0 && x<this.width && y>=0 && y<this.height){
			return this.data[y][x];
		} else {
			console.error("coordinate out of range");
		}
	}
	this.coordinate_set = function(x, y ,v){
		if (x>=0 && x<this.width && y>=0 && y<this.height){
			this.data[y][x] = v;
		} else {
			console.error("coordinate out of range");
		}
	}
	/* The row - column representation */
	this.rowcol = function(r, c) {
		return this.coordinate(c,r);
	}
	
	this.coordinate_silent = function(x, y){
		if (x>=0 && x<this.width && y>=0 && y<this.height){
			return this.data[y][x];
		} else {
			return 0;
		}
	}

	this.coordinate_shift = function(x, y){
		var r = new Array();
		/* FIXME: There might be massive memory leak here */
		for (var yy=0; yy<this.heigth; yy++) {
			this.data[yy] = new Array();
			for (var xx=0; xx<width; xx++) {
				this.data[yy][xx] = this.coordinate_silent(xx - x, yy - y);
			}
		}
	}
}

var world = {agents:null, death:null}
function global_env(){
	return world;
}
world.die = function(agent){
	for (var i = 0; i<this.agents.length; i++){
		if(this.agents[i] == agent) {
			this.agents.splice(i,1);
		}
	}
	this.death.push(agent);
}
world.birth = function(agent){
    this.agents.push(agent);
}
var MIN_MOVE_GAP = 20;
/*  
 *  loc: coordinate, 
 *  map: map,
 *  d: int <= distance of the view
 */
var agent = function (id, loc, map, d, lambda, speed, itg) {
	this.mark = 0;
	this.id = id;
	this.intelligence = itg;


	// FIXME: pos_x and pos_y are rendering attributes, please move
	this.update = function() {
		this.pos_x = this.loc.x * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;
		this.pos_y = this.loc.y * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;
		this.mark += this.map.get_tile_resource(this.loc.x, this.loc.y);
		this.map.set_tile_resource(this.loc.x, this.loc.y,0);
		this.size = this.mark/5+10;
		if (this.mark <= 0 ){
			global_env().die(this);
		} else if (this.mark > 100) {
            var birth = null;
            birth = new agent(this.id, this.loc, this.map, this.view_distance, this.lambda,this.speed, this.intelligence);
            birth.loc = this.map.offset(birth.loc,-1,-1);
            if (birth.loc) {
                birth.mark = 20;
                global_env().birth(birth);
            }
            birth = new agent(this.id, this.loc, this.map, this.view_distance, this.lambda,this.speed, this.intelligence);
            birth.loc = this.map.offset(birth.loc,+1,+1);
            if (birth.loc) {
                birth.mark = 20;
                global_env().birth(birth);
            }
            this.mark = 70;
        }

        
	}	
    this.survive = function() {
		this.mark = this.mark - 1;
    }

	this.speed = speed;

	this.size = 10;


	// Main attributes of the agent
	this.loc = loc;
	this.map = map;
	this.lambda = lambda;
	this.actions = generate_actions(this);
	this.view_distance = d;
	this.view = new Array();
	for (var a=0; a<this.actions.length; a++) {
		this.view[a] = new Matrix2D(2*d+1, 2*d+1);
	}
	this.mark;

	/* Given a coordinate, return its estimate if it is in the memory or view, else return 0 
         */
	this.estimate = function(aid, loc) {
		var d = this.view_distance;
		if ((loc.x - this.loc.x) + d >= 0 && (this.loc.x - loc.x) + d >= 0) {
			if ((loc.y - this.loc.y) + d >=0 && (this.loc.y - loc.y) + d >= 0) {
				// need to change coordinate back
				return this.view[aid].coordinate(loc.x - this.loc.x + d,loc.y - this.loc.y + d);
			} else {
				return 0;
			}
		} else { // This part can be extended to fits its AI 
			return 0;
		} 
	}
	this.policy = function(loc) {
		var max = -1; 
		var aid = -1;
		for (var i=0; i<this.actions.length; i++) {
			var c = this.estimate(i, loc);
			if (c > max) {
				max = c;
				aid = i;
			}
		}
		return aid;
	}
	this.learn = function () {
		for(var i=0; i<this.actions.length; i++) {
			for (var offset_x = 0; offset_x < 2*this.view_distance + 1; offset_x ++) {
				for (var offset_y = 0; offset_y <2*this.view_distance + 1; offset_y ++) {
					/* Get the location on the map of the view point in the view */
					var source_loc = this.map.offset(this.loc, offset_x-d, offset_y-d);
					if (source_loc == null) {
						this.view[i].coordinate_set(offset_x,offset_y,0);
					} else {
                        var result_loc = this.actions[i].attempt(source_loc);
                        if (result_loc) {
						    result_loc = this.map.offset(result_loc,0,0);
                        }
						if (result_loc == null) { // An invalid action
							this.view[i].coordinate_set(offset_x,offset_y,0);
						} else {
							this.view[i].coordinate_set(offset_x,offset_y,map_gain(this.map, result_loc, this.actions[i]));
							if(isNaN(map_gain(this.map, result_loc, this.actions[i]))) {
								console.error("gain is not a number!");
							}
							var aid = this.policy(result_loc);
							if (aid >=0 ) {
								var potential_estimate = this.estimate(aid, result_loc);
								if(isNaN(potential_estimate)) {
									console.error("potential estimation is NaN");
								}
								this.view[i].coordinate_set(offset_x,offset_y,this.view[i].coordinate(offset_x,
                                offset_y) + Math.floor(0.5 * potential_estimate));
							}
						}
					}
				}
			}
		}
	}
	this.train = function(round) {
		for (var i=0; i<round; i++) {
			this.learn();
		}
	}

	this.step = function() {
		if (this.slice <= 0) {
			var aid = this.policy(this.loc);
			var loc = this.actions[aid].do(this.loc);
			for(var i=0;i<this.actions.length;i++){
				this.view[i].coordinate_shift(loc.x - this.loc.x, loc.y - this.loc.y);
			}
			this.loc = loc;
			this.update();	
			this.train(this.intelligence);
			this.slice = 20;
		} else {
			this.slice = this.slice - this.speed;
            this.survive();
		}
	}
	this.learn();
	this.slice = 20;
	
	/* some dumb code for rendering purpose, which should be moved out */
	this.pos_x = this.loc.x * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;
	this.pos_y = this.loc.y * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;

}

var gen_map = function (width, height) {
	var m = new map(width, height);
	for (var i=0; i<width; i++) {
		for (var j=0; j<height; j++) {
			m.set_tile_resource(i,j,rand_integer(15));
		}
	}
	return m;
}


var gen_agents = function (map, num) {
	var agents = [];
	var i = 0;
	for (var i = 0; i<num; i++) {
		var pos = new coordinate(5 + rand_integer(25), 5 + rand_integer(25), map);
        //var pos = new coordinate(0,0,map);
		agents[i] = new agent(i, pos, map, 2, 0.8, rand_integer(10)+1, rand_integer(4)+1);
		//agents[i] = new agent(pos, map, 2, 0.8, 10);
	}
	return agents;
}


/* Setup the html demo application */

var app = angular.module('myApp', []);

// Create a map of 20 * 20
var map = gen_map(30,30);


var total_agents = 10;
// Create 10 agents distributed randomly
var agents = gen_agents(map, total_agents);
var corpses = new Array();
world.death = corpses;
var step = function() {
	map.regenerate();
	
	for(var i=0; i<agents.length; i++) {
		agents[i].step();
	}

}
var clear;

world.agents = agents;
app.controller('ctrl', function($scope,$interval) {
	$scope.map = map;
    $scope.agents = agents;
	$scope.death = corpses;
	$scope.focus = agents[0];
	$scope.focus_agent = function(f){
		$scope.focus = f;
	}
	$scope.start = function(){
		//step();
		clear = $interval (step,100);
	}
	$scope.end = function(){
		$interval.cancel(clear);
	}
	$scope.learn = function(){
		$scope.focus.learn();
	}
	$scope.step = function(){
		$scope.focus.step();
	}
	$scope.gen_gray_color = function gen_gray_color(val) {
		var char = (0xff - val).toString(16);
		return char + char + char;
	}
});
</script>
<body>
<header class="navbar navbar-static-top" style="border-bottom:1px solid gray">
	<div class="container">
		<h1>survive playground</h1>
	</div>
</header>


<div ng-app="myApp" ng-controller="ctrl">
	<div class="col-md-2" >
  		<button ng-click="start()">play</button>
		<button ng-click="end()">end</button>
		<button ng-click="learn()">learn</button>
		<button ng-click="step()">step</button>	
  		<p>X: {{focus.pos_x}}</p>
  		<p>Y:{{focus.pos_y}}</p>
		<p>speed: {{focus.speed}}</p>
		<p>wait: {{focus.slice}}</p>
		<p>mark: {{focus.mark}}</p>
		<p>intelligence: {{focus.intelligence}}</p>
		<div ng-repeat="a in focus.view">
			<h4>action {{focus.actions[$index].name}}</h4>
			<div ng-repeat="x in a.data">

			<p>{{x[0]}},{{x[1]}},{{x[2]}},{{x[3]}},{{x[4]}}</p>
			</div>
		</div>
	</div>
	<div class="col-md-6">
		<div ng-repeat="tile in map.tiles"
			style="position:absolute;
			  left:{{tile.loc.x * 20}}px;
			  top:{{tile.loc.y * 20}}px;
			  display:blocked;
			  width:20px;text-align:center;
			  height:20px;background-color:#{{gen_gray_color(tile.res)}}">
              {{tile.res}}
		</div>
	
		<div ng-repeat="agent in agents"
			ng-click="focus_agent(agent)"
			style="position:absolute;
			  top:{{agent.pos_y}}px;
			  left:{{agent.pos_x}}px;
			  display:blocked; text-align:center;
			  width:{{agent.size}}px;
			  height:{{agent.size}}px;border:2px solid black;
			  ">
		</div>
	</div>
	<div class="col-md-2">
        <h4>active list {{agents.length}}</h4>
		<ul class="list-inline">
		<li ng-repeat="agent in agents">agent id: {{agent.id}}, speed: {{agent.speed}}, int: {{agent.intelligence}} </li>
		</ul>
	</div>
	<div class="col-md-2">
        <h4>dead list</h4>
		<ul class="list-inline">
		<li ng-repeat="agent in death">agent id: {{agent.id}}, speed: {{agent.speed}}, int: {{agent.intelligence}} </li>
		</ul>
	</div>


</div>
</body>
</html>
