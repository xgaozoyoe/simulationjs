<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
<script src="http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"></script>
</head>
	
<script>

var rand_integer = function(ceil) {
	return Math.floor(ceil * Math.random ());
}

var world = {agents:null, death:null, events:new Array()};

/* x must in width range and y must in height range */

var box_boundary_out = function(top, right, bottom, left, loc) {
    return (loc.x < left || loc.x >= right || loc.y < top || loc.y >= bottom);
}

function map_boundary(map) {
	var fn = function(loc) {
		return box_boundary_out(0,map.width,map.height,0,loc);
	}
	return fn;
}

function coordinate(x, y, map) {
	this.map = map;
	this.x = x;
	this.y = y;
}

function tile(loc, res) {
	this.loc = loc;
	this.res = res;
	this.reg = 0;
	this.regen_rate = 10;
	this.slice = 0;
    this.agents = new Array();
	this.regenerate = function(){
		if (this.slice == this.reg_rate){
			this.slice = 0;
			this.res += this.reg;
		}else{
			this.slice += 1;
		}
	}
    this.agent_enter_hook = function(agent){
	    this.agents.push(agent);
    }
    this.agent_leave_hook = function(agent){
    	for (var i = 0; i<this.agents.length; i++){
		    if(this.agents[i] == agent) {
			    this.agents.splice(i,1);
		    }
	    }
    }
    this.agent_die_hook = function(agent){
   	    for (var i = 0; i<this.agents.length; i++){
		    if(this.agents[i] == agent) {
			    this.agents.splice(i,1);
		    }
	    }
    }
}

function map(width, height) {
	this.width = width;
	this.height = height;
	this.boundary = [map_boundary(this)];
	this.offset = function(loc, x, y) {
		var new_loc = new coordinate(loc.x + x, loc.y + y, this);
		for(var i = 0; i < this.boundary.length; i++) {
			var out = this.boundary[i](new_loc);
			if (out) {
				return null;
			}
		}
		return new_loc;
	}
	this.tiles = new Array();
	for (var i=0; i<width; i++) {
		for (var j=0; j<height; j++) {
			this.tiles[j * width + i] = new tile({x:i, y:j}, 0);
			this.tiles[j * width + i].reg = rand_integer(5);
			this.tiles[j * width + i].reg_rate = rand_integer(10)+30;
		}
	}
	this.set_tile_resource = function(x, y, v){
		this.tiles[y * width + x ].res = v;
	}
	this.get_tile_resource = function(x,y) {
		return this.tiles[y * width + x].res;
	}

	this.regenerate = function(){
		for (var i=0; i<width; i++) {
			for (var j=0; j<height; j++) {
					this.tiles[j * width + i].regenerate();
			}
		}
	}
	this.get_tile = function(x,y){
		return this.tiles[y*width + x];
	}
}

var Action = function(name, category, act, attempt){
    this.name = name;
	this.category = category;
    this.do = act;
    this.attempt = attempt;
}

var ActionCategory = {
	ACTION_MOVE:1,
	ACTION_AFFEND:2,
	ACTION_DEFEND:3,
	ACTION_COLLECT:4,
    ACTION_HUNT:5
}
/* Standard movement action functor */
var move = function(direction) {
    var fn = function (loc, agent) {
		var attempt_loc = direction(loc);
		if (loc.map.offset(attempt_loc, 0, 0) != null) {
			return attempt_loc;
		} else {
			return loc;
		}
	}
	return fn;
}

var try_move = function(direction) {
    var fn = function (loc, agent) {
		var attempt_loc = direction(loc);
		if (loc.map.offset(attempt_loc, 0, 0) != null) {
			return attempt_loc;
		} else {
			null;
		}
	}
	return fn;
}

var stay = function(loc, agent){
	var map = loc.map;
	agent.energy += map.get_tile_resource(agent.loc.x, agent.loc.y);
	map.set_tile_resource(this.loc.x, this.loc.y,0);
	return loc;
}

var try_stay = function(loc, agent){
	return loc;
}

var try_hunt = function(loc, agent){
    return loc;
}

var hunt = function(loc, agent){
    var tile = loc.map.get_tile(loc.x, loc.y);
    for(var i = 0; i<tile.agents.length; i++) {
        //if(tile.agents[i].energy < agent.energy) {
            world.die(tile.agents[i].energy);
            agent.energy += tile.agents[i].energy;
            tile.agent_leave_hook(tile.agents[i]);
            return loc;
            //break;
        //}
    }
    return loc;
}

function _left(loc) {return new coordinate(loc.x-1, loc.y, loc.map);} 
function _right(loc) {return new coordinate(loc.x+1, loc.y, loc.map);} 
function _top(loc) {return new coordinate(loc.x, loc.y-1, loc.map);} 
function _bottom(loc) {return new coordinate(loc.x, loc.y+1, loc.map);} 

/* For general actions an agent can take */
var move_left =  new Action("MLeft", ActionCategory.ACTION_MOVE, move(_left), try_move(_left));
var move_right = new Action("MRight", ActionCategory.ACTION_MOVE, move(_right), try_move(_right));
var move_top = new Action("MTop", ActionCategory.ACTION_MOVE, move(_top), try_move(_top));
var move_bottom = new Action("MBottom", ActionCategory.ACTION_MOVE, move(_bottom), try_move(_bottom));
var stay = new Action("MStay", ActionCategory.ACTION_COLLECT, stay, try_stay);
var hunt = new Action("MHunt", ActionCategory.ACTION_HUNT, hunt, try_hunt);

var normal_actions = [stay, move_left, move_right, move_top, move_bottom];
var predator_actions = [stay, move_left, move_right, move_top, move_bottom, hunt];

var map_gain = function (map, loc, action, caster) {
	if (loc != null) {
		if (action.category == ActionCategory.ACTION_MOVE) {
			return 0;
		}
		if (action.category == ActionCategory.ACTION_COLLECT) {
			return map.get_tile_resource(loc.x, loc.y);
		}
        if (action.category == ActionCategory.ACTION_HUNT) {
            var tile = loc.map.get_tile(loc.x, loc.y);
            if (tile.agents.length == 0){
                return 0;
            } else {
                for (var i=0;i<tile.agents.length;i++) {
                    if(tile.agents[i].energy < caster.energy && tile.agents[i].id < 1000) {
                        //alert(i);
                        return tile.agents[i].energy;
                    }
                }
                return 0;
            }
        }
		console.error("unsupported action!");
	} else {
		return -1;
	}
}

var Matrix2D = function(width, height){
	/* An Array of Array */
	/* (0,0) (1,0) 
	   (0,1) (1,1)
	 */
	this.data = new Array();
	this.width = width;
	this.height = height;
	for (var j=0; j<this.height; j++) {
		this.data[j] = new Array();
		for (var i=0; i<this.width; i++) {
			this.data[j][i] = 0;
		}
	}
	
	this.coordinate = function(x, y){
		if (x>=0 && x<this.width && y>=0 && y<this.height){
			return this.data[y][x];
		} else {
			console.error("coordinate out of range");
		}
	}
	this.coordinate_set = function(x, y ,v){
		if (x>=0 && x<this.width && y>=0 && y<this.height){
			this.data[y][x] = v;
		} else {
			console.error("coordinate out of range");
		}
	}
	/* The row - column representation */
	this.rowcol = function(r, c) {
		return this.coordinate(c,r);
	}
	
	this.coordinate_silent = function(x, y){
		if (x>=0 && x<this.width && y>=0 && y<this.height){
			return this.data[y][x];
		} else {
			return 0;
		}
	}

	this.coordinate_shift = function(x, y){
		var r = new Array();
		/* FIXME: There might be massive memory leak here */
		for (var yy=0; yy<this.heigth; yy++) {
			this.data[yy] = new Array();
			for (var xx=0; xx<width; xx++) {
				this.data[yy][xx] = this.coordinate_silent(xx - x, yy - y);
			}
		}
	}
}

function global_env(){
	return world;
}
world.die = function(agent){
	for (var i = 0; i<this.agents.length; i++){
		if(this.agents[i] == agent) {
			this.agents.splice(i,1);
		}
	}
	this.death.push(agent);
}
world.birth = function(agent){
    this.agents.push(agent);
}
var MIN_MOVE_GAP = 20;
var AgentAttribute = function(view, lambda, speed, itg, energy, reprate) {
	this.view_distance = view;
	this.lambda = lambda;
	this.speed = speed;
	this.intelligence = itg;
	this.energy = energy;
	this.reproduce_rate = reprate;
}
function reproduce(mother, init_actions)
{
	var rx = rand_integer(3) - 1;
	var ry = rand_integer(3) - 1;
	var loc = mother.map.offset(this.loc,rx,ry);
    if (loc) {
		// Initialize attributes for a new baby
		var attributes = new AgentAttribute(mother.attributes.view_distance,
			mother.attributes.lambda,
			mother.attributes.speed,
			mother.attributes.intelligence,
			20); // 20 energy for a new baby might be too much ?

    	birth = new Agent(mother.id, loc, mother.map, attributes, init_actions);
        global_env().birth(birth);
    }
}

/*  
 *  loc: coordinate, 
 *  map: map,
 */

var Agent = function (id, loc, map, attributes, init_actions) {

	// Main attributes of the agent
	this.id = id;
	this.loc = loc;
	this.map = map;
	this.view = new Array();
	this.size = 10;
	this.attributes = attributes;

	this.death_check = function(){
		return (this.attributes.energy <= 0);
	}

	this.reproduce_check = function(){
		return (this.attributes.energy > 100);
	}

	// FIXME: the rendering attributes should be splited into another module
	this.render = function() {
		this.pos_x = this.loc.x * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;
		this.pos_y = this.loc.y * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;

		this.size = this.energy/5+10;
	}

	this.step_finish = function() {
		if (this.death_check()) {
            this.map.get_tile(this.loc.x, this.loc.y).agent_die_hook(this);
			global_env().die(this);
		}
		if (this.reproduce_check()) {
			reproduce(this, init_actions);
            this.attribute.energy = 70;
        }
		this.render();
	}	

    this.survive = function() {
		this.energy = this.energy - 1;
    }

	this.add_action = function(action){
		this.actions[this.actions.length] = action;
		this.view[this.view.length] = new Matrix2D(2*this.attributes.view_distance + 1, 2*this.attributes.view_distance + 1);
	}

	// this.actions = generate_actions(this);
    // Extra actions
    for (var a=0; a<init_actions.length; a++) {
		this.add_action(init_actions[a]);
    }

	/* Given a coordinate, return its estimate if it is in the memory or view, else return 0 
         */
	this.estimate = function(aid, loc) {
		var d = this.attributes.view_distance;
		if ((loc.x - this.loc.x) + d >= 0 && (this.loc.x - loc.x) + d >= 0) {
			if ((loc.y - this.loc.y) + d >=0 && (this.loc.y - loc.y) + d >= 0) {
				// need to change coordinate back
				return this.view[aid].coordinate(loc.x - this.loc.x + d,loc.y - this.loc.y + d);
			} else {
				return 0;
			}
		} else { // This part can be extended to fits its AI 
			return 0;
		} 
	}
	this.policy = function(loc) {
		var max = -1; 
		var aid = -1;
		for (var i=0; i<this.actions.length; i++) {
			var c = this.estimate(i, loc);
			if (c > max) {
				max = c;
				aid = i;
			}
		}
		return aid;
	}

/* The main learning function which only depends on estimate and policy and view */
	this.learn = function () {
		var d = this.attributes.view_distance;
		var vsize = 2 * this.attributes.view_distance + 1; // the size of the array of the view

		for(var i=0; i<this.actions.length; i++) {
			for (var offset_x = 0; offset_x < vsize; offset_x ++) {
				for (var offset_y = 0; offset_y < vsize; offset_y ++) {
					/* Get the location on the map of the view point in the view */
					var source_loc = this.map.offset(this.loc, offset_x - d, offset_y - d);
					if (source_loc == null) {
						this.view[i].coordinate_set(offset_x,offset_y,0);
					} else {
                        var result_loc = this.actions[i].attempt(source_loc,this);
                        if (result_loc) {
						    result_loc = this.map.offset(result_loc,0,0);
                        }
						if (result_loc == null) { // An invalid action
							this.view[i].coordinate_set(offset_x,offset_y,0);
						} else {
							this.view[i].coordinate_set(offset_x,offset_y,
									map_gain(this.map, result_loc, this.actions[i],this));
							var aid = this.policy(result_loc);
							if (aid >=0 ) {
								var potential_estimate = this.estimate(aid, result_loc);
								this.view[i].coordinate_set(offset_x,offset_y,
									this.view[i].coordinate(offset_x, offset_y)
										+ Math.floor(0.5 * potential_estimate));
							}
						}
					}
				}
			}
		}
	}

/* Train the agent for serveral rounds depends on its intelligence */
	this.train = function(round) {
		for (var i=0; i<round; i++) {
			this.learn();
		}
	}

	this.step = function() {
		if (this.slice <= 0) {
			var aid = this.policy(this.loc);
			var loc = this.actions[aid].do(this.loc,this);
			for(var i=0;i<this.actions.length;i++){
				this.view[i].coordinate_shift(loc.x - this.loc.x, loc.y - this.loc.y);
			}
            this.map.get_tile(this.loc.x, this.loc.y).agent_leave_hook(this);
			this.loc = loc;
            this.map.get_tile(this.loc.x, this.loc.y).agent_enter_hook(this);

			this.step_finish();	
			this.train(this.attributes.intelligence);
			this.slice += 60;
		} else {
			this.slice = this.slice - this.attributes.speed;
            this.survive();
		}
	}

	this.learn();
	this.slice = 20;
    this.map.get_tile(this.loc.x, this.loc.y).agent_enter_hook(this);
	
	/* some dumb code for rendering purpose, which should be moved out */
	this.pos_x = this.loc.x * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;
	this.pos_y = this.loc.y * MIN_MOVE_GAP - (this.size-MIN_MOVE_GAP + 2)/2;

}

var gen_map = function (width, height) {
	var m = new map(width, height);
	for (var i=0; i<width; i++) {
		for (var j=0; j<height; j++) {
			m.set_tile_resource(i,j,rand_integer(15));
		}
	}
	return m;
}


var gen_agents = function (map, num) {
	var agents = [];
	var i = 0;
	for (var i = 0; i<num; i++) {
		var pos = new coordinate(5 + rand_integer(25), 5 + rand_integer(25), map);
        //var pos = new coordinate(0,0,map);
		var attributes = new AgentAttribute(2, 0.8, rand_integer(10)+1, rand_integer(4)+1, 0 , 1)
		agents[i] = new Agent(i, pos, map, attributes, normal_actions);
		//agents[i] = new agent(pos, map, 2, 0.8, 10);
	}
	return agents;
}


/* Setup the html demo application */

var app = angular.module('myApp', []);

// Create a map of 20 * 20
var map = gen_map(30,30);


var total_agents = 10;
// Create 10 agents distributed randomly
var agents = gen_agents(map, total_agents);
var corpses = new Array();
world.death = corpses;
world.next_wave_count = 100;
var step = function() {
	map.regenerate();
    world.next_wave_count -=1;	
	for(var i=0; i<agents.length; i++) {
		agents[i].step();
	}
    if (world.next_wave_count == 0){
        world.next_wave_count = 1000;
		var attribute = new AgentAttribute(3, 0.9, 15, 3, 40, 1);
        var birth = new Agent(1001, new coordinate(1,1,map) , map, attribute, predator_actions);
        global_env().birth(birth);
    }

}
var clear;

world.agents = agents;
app.controller('ctrl', function($scope,$interval) {
	$scope.map = map;
    $scope.agents = agents;
	$scope.death = corpses;
	$scope.focus = agents[0];
	$scope.focus_agent = function(f){
		$scope.focus = f;
	}
	$scope.start = function(){
		//step();
		clear = $interval (step,100);
	}
	$scope.end = function(){
		$interval.cancel(clear);
	}
	$scope.learn = function(){
		$scope.focus.learn();
	}
	$scope.step = function(){
		$scope.focus.step();
	}
	$scope.gen_gray_color = function gen_gray_color(val) {
		var char = (0xff - val).toString(16);
		return char + char + char;
	}
	$scope.gen_id_color = function gen_gray_color(val) {
        if (val > 1000){
		    var char = ((val - 1000)).toString(16);
            return "ff2342";
        }else{
		    var char = ((val)).toString(16);
            return "22f345"
        }
	}

    $scope.world = world;
});
</script>
<body>
<header class="navbar navbar-static-top" style="border-bottom:1px solid gray">
	<div class="container">
		<h1>survive playground</h1>
	</div>
</header>


<div ng-app="myApp" ng-controller="ctrl" style="width:1028px;margin:auto">
	<div class="col-md-8">

        <div style="font-size:20px">
            <span>Alience will land in next {{world.next_wave_count}} seconds</span>
            <div style="background-color:black;width:{{world.next_wave_count/2}}px;height:10px;">
            </div>
        </div>
        <div style="border-bottom:1px solid gray;
                margin-bottom:10px;
                padding:10px;font-size:20px">
                <span class="glyphicon glyphicon-play" ng-click="start()"></span>
		        <span class="glyphicon glyphicon-pause" ng-click="end()"></span>
		        <span class="glyphicon glyphicon-eye-open" ng-click="learn()"></span>
		        <span class="glyphicon glyphicon-step-forward" ng-click="step()"></span>	
        </div>

        <div style="position:absolute;">
		<div ng-repeat="tile in map.tiles"
			style="position:absolute;
			  left:{{tile.loc.x * 20}}px;
			  top:{{tile.loc.y * 20}}px;
			  display:blocked;
			  width:20px;text-align:center;
              border:{{tile.agents.length}}px solid yellow;
			  height:20px;background-color:#{{gen_gray_color(tile.res)}}">
              {{tile.res}}
		</div>
	
		<div ng-repeat="agent in agents"
			ng-click="focus_agent(agent)"
			style="position:absolute;
			  top:{{agent.pos_y}}px;
			  left:{{agent.pos_x}}px;
			  display:blocked; text-align:center;
			  width:{{agent.size}}px;
              background-color:#{{gen_id_color(agent.id)}};
			  height:{{agent.size}}px;border:2px solid black;
			  ">
		</div>
        </div>

	</div>
	<div class="col-md-4">
        <ul id="rightTab" class="nav nav-tabs">
	        <li class="active">
                <a href="#control" data-toggle="tab"> control panel</a>
	        </li>
	        <li>
                <a href="#alive_agents" data-toggle="tab"> population {{agents.length}}</a>
	        </li>
            <li>
                <a href="#dead_agents" data-toggle="tab"> corpse </a>
            </li>
        </ul>
        <div class="tab-content" id="rightTabContent">
            <div class="tab-pane fade in active" id="control" style="margin-top:5px;">
                <ul class="list-group">
		        <li class="list-group-item">speed: {{focus.attribues.speed}}</li>
		        <li class="list-group-item">wait: {{focus.attributes.slice}}</li>
		        <li class="list-group-item">energy: {{focus.attributes.energy}}</li>
		        <li class="list-group-item">intelligence: {{focus.attributes.intelligence}}</li>
                </ul>
		        <div ng-repeat="act in focus.view">
                <table class = "table">
			        <caption>action {{focus.actions[$index].name}}</caption>
                    <tbody>
			        <tr ng-repeat="row in act.data">
                        <td>{{row[0]}}</td>
                        <td>{{row[1]}}</td>
                        <td>{{row[2]}}</td>
                        <td>{{row[3]}}</td>
                        <td>{{row[4]}}</td>
			        </tr>
                    </tbody>
                </table>
		        </div>
            </div>
            <div class="tab-pane fade" id="alive_agents">
                <ul class="list-group" style="margin-top:10px">
		            <li class="list-group-item" ng-repeat="agent in agents">agent id: {{agent.id}}, speed: {{agent.attributes.speed}}, int: {{agent.attributes.intelligence}} </li>
		        </ul>
            </div>
            <div class="tab-pane fade" id="dead_agents">
		        <ul class="list-group" style="margin-top:10px">
		            <li class="list-group-item" ng-repeat="agent in death">agent id: {{agent.id}}, speed: {{agent.attributes.speed}}, int: {{agent.attributes.intelligence}} </li>
		        </ul>
            </div>
        </div>
	</div>


</div>
</body>
</html>
