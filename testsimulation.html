<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"></script>
</head>
	
<script>

var rand_integer = function(ceil) {
	return Math.floor(ceil * Math.random ());
}

/* x must in width range and y must in height range */

var box_boundary_out = function(top, right, bottom, left, loc) {
    return (loc.x < left || loc.x >= right || loc.y < top || loc.y >= bottom);
}

function map_boundary(map) {
	var fn = function(loc) {
		return box_boundary_out(0,map.width,map.height,0,loc);
	}
	return fn;
}

function coordinate(x, y, map) {
	this.map = map;
	this.x = x;
	this.y = y;
}

function tile(loc, res) {
	this.loc = loc;
	this.res = res;
}

function map(width, height) {
	this.width = width;
	this.height = height;
	this.boundary = [map_boundary(this)];
	this.offset = function(loc, x, y) {
		var new_loc = new coordinate(loc.x + x, loc.y + y, this);
		for(var i = 0; i < this.boundary.length; i++) {
			var out = this.boundary[i](new_loc);
			if (out) {
				return null;
			}
		}
		return new_loc;
	}
	this.resource = new Array();
	for (var i=0; i<width; i++) {
		for (var j=0; j<height; j++) {
			this.resource[j * width + i] = new tile({x:j, y:i}, 0);	
		}
	}
	this.set_tile_resource = function(x, y, v){
		this.resource[y * width + x ].res = v;
	}
	this.get_tile_resource = function(x,y) {
		return this.resource[y * width + x];
	}

	this.regenerate = function(){
		for (var i=0; i<width; i++) {
			for (var j=0; j<height; j++) {
				if (this.resource[j * width + i].res == 0){
					this.resource[j * width + i].res += rand_integer(6);	
				}
			}
		}

	}
}

var t = new map(1,1);



/* Standard movement action functor */
var move = function(direction) {
    var fn = function (loc) {
		var attempt_loc = direction(loc);
		if (loc.map.offset(attempt_loc, 0, 0) != null) {
			return attempt_loc;
		} else {
			return loc;
		}
	}
	return fn;
}

/* For general actions an agent can take */
var move_left = move( function(loc) {return new coordinate(loc.x-1, loc.y, loc.map);} );
var move_right = move( function(loc) {return new coordinate(loc.x+1, loc.y, loc.map);} );
var move_top = move( function(loc) {return new coordinate(loc.x, loc.y-1, loc.map);} );
var move_bottom = move( function(loc) {return new coordinate(loc.x, loc.y+1, loc.map);} );

var actions = [move_left, move_right, move_top, move_bottom];

/* Provided an agent, create an array of actions */
function generate_actions(agent) {
	return actions;
}

var map_gain = function (map, loc) {
	if (loc != null) {
		return map.get_tile_resource(loc.x, loc.y).res;
	} else {
		return -1;
	}
}
/*  
 *  loc: coordinate, 
 *  map: map,
 *  d: int <= distance of the view
 */
var agent = function (loc, map, d, lambda, speed) {

	// FIXME: pos_x and pos_y are rendering attributes, please move
	this.update = function() {
		this.pos_x = this.loc.x * 10;
		this.pos_y = this.loc.y * 10;
		this.mark = this.map.get_tile_resource(this.loc.x, this.loc.y).res;
		this.map.set_tile_resource(this.loc.x, this.loc.y,0);
	}	

	this.speed = speed;

	this.size = 30-speed * 2;


	// Main attributes of the agent
	this.loc = loc;
	this.map = map;
	this.lambda = lambda;
	this.actions = generate_actions(this);
	this.view_distance = d;
	this.view = new Array();
	for (var a=0; a<this.actions.length; a++) {
		this.view[a] = new Array();
		for (var i=0; i<2*d+1; i++) {
			this.view[a][i] = new Array();
			for (var j=0; j<2*d+1; j++) {
				this.view[a][i][j] = 0;
			}
		}
	}
	this.mark;

	/* Given a coordinate, return its estimate if it is in the memory or view, else return 0 
         */
	this.estimate = function(aid, loc) {
		var d = this.view_distance;
		if ((loc.x - this.loc.x) + d >= 0 && (this.loc.x - loc.x) + d >= 0) {
			if ((loc.y - this.loc.y) + d >=0 && (this.loc.y - loc.y) + d >= 0) {
				// need to change coordinate back
				return this.view[aid][loc.x - this.loc.x + d][loc.y - this.loc.y + d];
			} else {
				return 0;
			}
		} else { // This part can be extended to fits its AI 
			return 0;
		} 
	}
	this.policy = function(loc) {
		var max = -1; 
		var aid = -1;
		for (var i=0; i<this.actions.length; i++) {
			var result_loc = this.actions[i](loc);
			if (result_loc != null) {
				var c = this.estimate(i, loc);
				if (c > max) {
					max = c;
					aid = i;
				}
			}
		}
		return aid;
	}
	this.learn = function () {
		for(var i=0; i<actions.length; i++) {
			for (var offset_x = 0; offset_x < 2*this.view_distance + 1; offset_x ++) {
				for (var offset_y = 0; offset_y <2*this.view_distance + 1; offset_y ++) {
					var source_loc = this.map.offset(this.loc, offset_x-d, offset_y-d);
					if (source_loc == null) {
						this.view[i][offset_x][offset_y] = 0;
					} else {
						if (source_loc.y<0) {
							source_loc = this.map.offset(source_loc, 0, 0);
						}
						var result_loc = this.map.offset(this.actions[i](source_loc),0,0);
						if (result_loc == null) { // An invalid action
							this.view[i][offset_x][offset_y] = 0;
						} else {
							this.view[i][offset_x][offset_y] = map_gain(this.map, result_loc);
							if(isNaN(map_gain(this.map, result_loc))) {
								var g = map_gain(this.map, result_loc);
							}
							var aid = this.policy(result_loc);
							if (aid >=0 ) {
								var potential_estimate = this.estimate(aid, this.actions[aid](result_loc));
								if(isNaN(potential_estimate)) {
									return this.estimate(aid, this.actions[aid](result_loc));
								}
								this.view[i][offset_x][offset_y] += potential_estimate;
							}
						}
					}
				}
			}
		}
	}
	this.training = function(round) {
		for (var i=0; i<round; i++) {
			this.learn();
		}
	}

	this.step = function() {
		if (this.slice <= 0) {
			var aid = this.policy(this.loc);
			this.loc = this.actions[aid](this.loc);
			this.update();	
			this.learn();
			this.slice = 20;
		} else {
			this.slice = this.slice - this.speed;
		}
	}
	this.update();
	this.learn();
	this.slice = 20;
}

var gen_map = function (width, height) {
	var m = new map(width, height);
	for (var i=0; i<width; i++) {
		for (var j=0; j<height; j++) {
			m.set_tile_resource(i,j,rand_integer(15));
		}
	}
	return m;
}


var gen_agents = function (map, num) {
	var agents = [];
	var i = 0;
	for (var i = 0; i<num; i++) {
		var pos = new coordinate(5 + rand_integer(25), 5 + rand_integer(25), map);
		agents[i] = new agent(pos, map, 2, 0.8, rand_integer(10));
	}
	return agents;
}


/* Setup the html demo application */

var app = angular.module('myApp', []);

// Create a map of 20 * 20
var map = gen_map(50,50);


var total_agents = 30;
// Create 10 agents distributed randomly
var agents = gen_agents(map, total_agents);

var step = function() {
	for(var i=0; i<total_agents; i++) {
		agents[i].step();
	}
	map.regenerate();
}
var clear;

app.controller('ctrl', function($scope,$interval) {
	$scope.map = map;
    $scope.agents = agents;
	$scope.focus = agents[0];
	$scope.focus_agent = function(f){
		$scope.focus = f;
	}
	$scope.start = function(){
		//step();
		clear = $interval (step,100);
	}
	$scope.end = function(){
		$interval.cancel(clear);
	}
	$scope.gen_gray_color = function gen_gray_color(val) {
		var char = (0xff - val).toString(16);
		return char + char + char;
	}
});
</script>
<body>



<div ng-app="myApp" ng-controller="ctrl">
	<div style="float:right">
  		<p>{{focus.pos_x}}</p>
  		<p>{{focus.pos_y}}</p>
  		<button ng-click="start()">play</button>
		<button ng-click="end()">end</button>
		<div ng-repeat="a in focus.view">
			[
			<div ng-repeat="c in a" style="">
					{{c[0]}},{{c[1]}},{{c[2]}},{{c[3]}},{{c[4]}}	
			</div>
			]
		</div>
	</div>
  	<div ng-repeat="tile in map.resource"
	   style="position:fixed;
			  left:{{tile.loc.x * 10}}px;
			  top:{{tile.loc.y * 10}}px;
			  display:blocked;
			  width:10px;
			  height:10px;background-color:#{{gen_gray_color(tile.res)}}">
	</div>

  	<div ng-repeat="agent in agents"
	   ng-click="focus_agent(agent)"
	   style="position:fixed;
			  top:{{agent.pos_x}}px;
			  left:{{agent.pos_y}}px;
			  display:blocked;
			  width:{{agent.size}}px;
			  height:{{agent.size}}px;border:1px dotted black;
			  background-color:#{{gen_gray_color(agent.mark)}}">
	</div>

</div>
</body>
</html>
