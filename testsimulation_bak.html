<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"></script>
</head>
	
<script>

var rand_integer = function(ceil) {
	return Math.floor(ceil * Math.random ());
}

/* x must in width range and y must in height range */

var box_boundary_out = function(top, right, bottom, left, loc) {
    return (loc.x < left || loc.x > right || left.y <top || left.y > bottom);
}

var map_boundary = function(map) {
	var fn = function(loc) {
		return box_boundary_out(0,map.width,map.height,0);
	}
	return fn;
}
/*
var coordinate = function(x, y, map) {
	this.map = map;
	this.x = x;
	this.y = y;
}

*/

var map = function(width, height) {
	this.witdh = width;
	this.height = height;
	this.boundary = [map_boundary(this)];
	this.offset = function(loc, x, y) {
		loc = new coordinate(loc.x + x, loc.y + y);
		for(i = 0; i < loc.map.boundary.length; i++) {
			if (loc.map.boundary[i](attempt_loc)) {
				return null;
			}
		}
		return loc;
	}
	this.resource = int[width][height];
}



/* Standard movement action functor */
var move = function(direction) {
    var fn = function (loc) {
		attempt_loc = direction(loc);
		if (map.offset(attempt_loc, 0, 0) != null) {
			loc.x = attempt_loc.x;
			loc.y = attempt_loc.y;
		}
	}
	return fn;
}

/* For general actions an agent can take */
/*
var move_left = move( function(loc) {return new coordinate(loc.x-1, loc.y, loc.map);} );
var move_right = move( function(loc) {return new coordinate(loc.x+1, loc.y, loc.map);} );
var move_top = move( function(loc) {return new coordinate(loc.x, loc.y-1, loc.map);} );
var move_bottom = move( function(loc) {return new coordinate(loc.x, loc.y+1, loc.map);} );

var actions = [move_left, move_right, move_top, move_bottom];

// Provided an agent, create an array of actions
var action_gen = function(agent) {
	return actions;
}

var map_gain = function (map, loc) {
	if (loc != null) {
		return map.resource[loc.x][loc.y];
	} else {
		return 0;
	}
}
*/

/*  
 *  loc: coordinate, 
 *  map: map,
 *  d: int <= distance of the view
 */
/*
var agent = function (loc, map, d, lambda) {

	// FIXME: pos_x and pos_y are rendering attributes, please move
	this.update = function() {
		this.pos_x = this.loc.x * 10;
		this.pos_y = this.loc.y * 10;
	}	


	// Main attributes of the agent
	this.loc = loc;
	this.map = map;
	this.lambda = lambda;
	this.actions = generate_actions(this);
	this.view = int[d][d];
	this.mark;

	//Given a coordinate, return its estimate if it is in the memory or view, else return 0
	this.estimate = function(aid, loc) {
		if ((loc.x - this.loc.x) + d >=0 && (this.loc.x - loc.x) >= 0) {
			if ((loc.y - this.loc.y) + d >=0 && (this.loc.y - loc.y) >= 0) {
				return this.view[aid][loc.x][loc.y];
			}
		} else { // This part can be extended to fits its AI 
			return 0;
		} 
	}
	this.policy = function(loc) {
		var max = 0;
		var aid = -1;
		for (i=0; i<actions; i++) {
			var result_loc = this.actions[i](loc);
			if (result_loc != null) {
				var c = this.estimate(i, loc);
				if (c > max) {
					max = c;
					aid = i;
				}
			}
		}
		return aid;
	}
	this.learn = function () {
		for(i=0; i<actions; i++) {
			for (offset_x = 0; offset_x < 2*d + 1; offset_x ++) {
				for (offset_y = 0; offset_y <2*d + 1; offset_y ++) {
					var result_loc = this.actions[i](map_offset(this.loc, offset_x-d, offset_y-d));
					if (result_loc == null) { // An invalid action
						this.view[i][offset_x][offset_y] = 0;
					} else {
						this.view[i][offset_x][offset_y] = map_gain(this.map, result_loc);
					}
					var aid = this.policy(resullt_loc);
					if (aid >=0 ) {
						var potential_estimate = this.estimate(aid, this.actions[aid](result_loc));
						this.view[i][offset_x][offset_y] += potential_estimate;
					}
				}
			}
		}
	}
	this.training = function(round) {
		for (i=0; i<round; i++) {
			this.learn();
		}
	}

	this.step = function() {
		var aid = this.policy(this.loc);
		this.loc = this.actions[aid](loc);
		this.update();	
	}
	this.update();
	this.learn();
}

var gen_map = function (width, height) {
	var map = new map(width, height);
	for (i=0; i<width; i++) {
		for (j=0; j<height; j++) {
			map.resource = rand_integer(25);
		}
	}
}


var gen_agents = function (map, num) {
	var agents = [];
	var i = 0;
	for (i = 0; i<num; i++) {
		//var pos = {x:rand_integer(10), y:rand_integer(10)};
		var pos = {x:10, y:10};
		//agents[i] = new agent(pos, map, 5, 0.8);
	}
	return agents;
}
*/


/* Setup the html demo application */

//var app = angular.module('myApp', []);


/*
// Create a map of 20 * 20
var map = gen_map(20,20);


// Create 10 agents distributed randomly
var agents = gen_agents(map, 10);

var step = function() {
	for(var i=0; i<10; i++) {
		agents[i].step();
	}
}
var clear;

app.controller('ctrl', function($scope,$interval) {
	$scope.map = map;
    $scope.agents = agents;
	$scope.focus = agents[0];
	$scope.focus_agent = function(f){
		$scope.focus = f;
	}
	$scope.start = function(){
		clear = $interval (step,100);
	}
	$scope.end = function(){
		$interval.cancel(clear);
	}
});
*/	
</script>
<body>

</body>
</html>
